<!DOCTYPE html>
<html lang="zh-CN">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
	<title>PureStory图片擦除工具</title>
	<script src="spark-md5.min.js"></script>
	<style>
		* {
			margin: 0;
			padding: 0;
			box-sizing: border-box;
		}

		body {
			font-family: Arial, sans-serif;
			background-color: #f0f0f0;
			min-height: 100vh;
			display: flex;
			flex-direction: column;
		}

		.container {
			max-width: 100%;
			margin: 0 auto;
			padding: 0 15px;
			height: 100vh;
			display: flex;
			flex-direction: column;
		}

		.controls {
			background: white;
			padding: 10px;
			border-radius: 8px;
			margin-bottom: 10px;
			box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
			flex-shrink: 0;
		}

		.brush-controls {
			margin-top: 15px;
			display: flex;
			align-items: center;
			gap: 15px;
			flex-wrap: wrap;
		}

		.canvas-container {
			position: relative;
			overflow: auto;
			background: #fff;
			border-radius: 8px;
			box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
			margin-bottom: 10px;
			flex: 1;
			min-height: 0;
		}

		canvas {
			display: block;
			margin: 0 auto;
			touch-action: none;
		}

		button {
			padding: 4px 8px;
			background-color: #4CAF50;
			color: white;
			border: none;
			border-radius: 4px;
			cursor: pointer;
			font-size: 12px;
			min-width: 40px;
		}

		button:hover {
			background-color: #45a049;
		}

		input[type="range"] {
			width: 200px;
		}

		.zoom-controls {
			display: flex;
			gap: 10px;
			margin-top: 10px;
		}

		.direction-controls {
			display: flex;
			flex-direction: column;
			align-items: center;
			gap: 10px;
			margin-top: 15px;
		}

		.horizontal-controls {
			display: flex;
			gap: 10px;
			width: 100%;
		}

		.horizontal-controls button {
			flex: 1;
		}

		.all-controls {
			display: flex;
			gap: 5px;
			margin-top: 10px;
			flex-wrap: nowrap;
		}

		.all-controls button {
			flex: 1;
			white-space: nowrap;
		}

		@media (max-width: 768px) {
			.container {
				margin: 5px auto;
				padding: 0 5px;
			}

			.controls {
				padding: 5px;
				margin-bottom: 5px;
			}

			.brush-controls {
				flex-direction: row;
				align-items: center;
				gap: 5px;
				margin-top: 5px;
			}

			input[type="range"] {
				width: 100px;
			}

			button {
				width: auto;
				font-size: 12px;
				padding: 4px;
			}

			.all-controls {
				flex-direction: row;
				gap: 3px;
			}

			.all-controls button {
				padding: 4px 2px;
				min-width: 30px;
			}
		}

		.toast {
			position: fixed;
			top: 20px;
			left: 50%;
			transform: translateX(-50%);
			background-color: rgba(0, 0, 0, 0.8);
			color: white;
			padding: 10px 20px;
			border-radius: 4px;
			z-index: 1000;
			display: none;
			animation: fadeInOut 3s ease-in-out;
		}

		@keyframes fadeInOut {
			0% {
				opacity: 0;
			}

			10% {
				opacity: 1;
			}

			90% {
				opacity: 1;
			}

			100% {
				opacity: 0;
			}
		}

		/* 添加任务列表样式 */
		.task-panel {
			background: white;
			padding: 10px;
			border-radius: 8px;
			margin: 10px 0;
			box-shadow: 0 2px 4px rgba(0,0,0,0.1);
			transition: all 0.3s ease;
		}
		
		.task-panel.collapsed {
			padding: 0;
		}
		
		.task-panel.collapsed .task-list,
		.task-panel.collapsed .task-pagination {
			display: none;
		}
		
		.task-header {
			display: flex;
			justify-content: space-between;
			align-items: center;
			padding: 10px;
			border-bottom: 1px solid #eee;
			cursor: pointer;
		}
		
		.task-panel.collapsed .task-header {
			border-bottom: none;
			margin-bottom: 0;
			padding-bottom: 10px;
		}
		
		.task-header:hover {
			background-color: #f5f5f5;
		}
		
		.task-header-left {
			display: flex;
			align-items: center;
			gap: 10px;
		}
		
		.task-header h3 {
			margin: 0;
			font-size: 16px;
			display: flex;
			align-items: center;
			gap: 5px;
		}
		
		.task-header h3::after {
			content: "▼";
			font-size: 12px;
			transition: transform 0.3s ease;
		}
		
		.task-panel.collapsed .task-header h3::after {
			transform: rotate(-90deg);
		}
		
		.task-count {
			background: #4CAF50;
			color: white;
			padding: 2px 8px;
			border-radius: 12px;
			font-size: 12px;
		}
		
		.task-list {
			max-height: 200px;
			overflow-y: auto;
		}
		
		.task-item {
			display: flex;
			align-items: center;
			padding: 8px;
			border-bottom: 1px solid #eee;
			gap: 10px;
		}
		
		.task-item:last-child {
			border-bottom: none;
		}
		
		.task-info {
			flex: 1;
		}
		
		.task-status {
			font-size: 12px;
			padding: 2px 6px;
			border-radius: 4px;
			color: white;
		}
		
		.task-status.pending {
			background: #FFA000;
		}
		
		.task-status.processing {
			background: #2196F3;
		}
		
		.task-status.completed {
			background: #4CAF50;
		}
		
		.task-status.error {
			background: #F44336;
		}
		
		.task-progress {
			height: 4px;
			background: #eee;
			border-radius: 2px;
			margin-top: 4px;
		}
		
		.task-progress-bar {
			height: 100%;
			background: #4CAF50;
			border-radius: 2px;
			transition: width 0.3s ease;
		}
		
		.task-result {
			width: 40px;
			height: 40px;
			object-fit: cover;
			border-radius: 4px;
			cursor: pointer;
		}
		
		.task-result:hover {
			transform: scale(1.1);
		}
		
		@media (max-width: 768px) {
			.task-panel {
				margin: 5px 0;
				padding: 5px;
			}
			
			.task-list {
				max-height: 150px;
			}
			
			.task-item {
				padding: 5px;
			}
			
			.task-result {
				width: 30px;
				height: 30px;
			}
		}

		/* 添加刷新按钮样式 */
		.refresh-btn {
			background: none;
			border: none;
			padding: 5px;
			cursor: pointer;
			color: #666;
			display: flex;
			align-items: center;
			justify-content: center;
			border-radius: 50%;
			min-width: auto;
			transition: all 0.3s ease;
		}
		
		.refresh-btn:hover {
			background: #f0f0f0;
			color: #4CAF50;
		}
		
		.refresh-btn.spinning svg {
			animation: spin 1s linear infinite;
		}
		
		@keyframes spin {
			from {
				transform: rotate(0deg);
			}
			to {
				transform: rotate(360deg);
			}
		}

		/* 添加分页样式 */
		.task-pagination {
			display: flex;
			justify-content: center;
			align-items: center;
			gap: 5px;
			margin-top: 10px;
			padding-top: 10px;
			border-top: 1px solid #eee;
		}
		
		.page-btn {
			padding: 4px 8px;
			background: #f5f5f5;
			border: 1px solid #ddd;
			border-radius: 4px;
			cursor: pointer;
			color: #666;
			min-width: 30px;
			text-align: center;
			font-size: 12px;
		}
		
		.page-btn:hover {
			background: #e0e0e0;
		}
		
		.page-btn.active {
			background: #4CAF50;
			color: white;
			border-color: #4CAF50;
		}
		
		.page-btn:disabled {
			background: #f5f5f5;
			color: #ccc;
			cursor: not-allowed;
		}
		
		.page-info {
			font-size: 12px;
			color: #666;
		}
	</style>
</head>

<body>
	<div class="container">
		<div class="controls">
			<input type="file" id="imageInput" accept="image/*">
			<div class="brush-controls">
				<label>画笔大小: <span id="brushSize">10</span>px</label>
				<input type="range" id="brushSizeInput" min="1" max="500" value="10">
				<button id="undoBtn">撤销</button>
				<button id="clearBtn">清除</button>
				<button id="uploadImageLamaBtn">Lama修复</button>
			</div>
			<div class="all-controls">
                <button id="moveUp">↑ 上移</button> <button id="moveDown">↓ 下移</button>
				<button id="moveLeft">← 左移</button> <button id="moveRight">→ 右移</button>
				<button id="zoomIn">放大</button> <button id="zoomOut">缩小</button>
				<button id="resetZoom">重置</button>
			</div>
		</div>
		
		<!-- 添加任务列表显示区域 -->
		<div class="task-panel" id="taskPanel">
			<div class="task-header" id="taskHeader">
				<div class="task-header-left">
					<h3>任务列表</h3>
					<span class="task-count" id="taskCount"></span>
				</div>
				<button id="refreshTasksBtn" class="refresh-btn" title="刷新任务列表">
					<svg viewBox="0 0 24 24" width="16" height="16">
						<path fill="currentColor" d="M17.65 6.35A7.958 7.958 0 0012 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08A5.99 5.99 0 0112 18c-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z"/>
					</svg>
				</button>
			</div>
			<div class="task-list" id="taskList">
				<!-- 任务列表将在这里动态生成 -->
			</div>
			<div class="task-pagination" id="taskPagination">
				<!-- 分页控件将在这里动态生成 -->
			</div>
		</div>
		<div class="canvas-container">
			<canvas id="imageCanvas"></canvas>
		</div>
	</div>

	<div class="toast" id="toast">
		<!-- Toast content will be dynamically added here -->
	</div>

	<script>
		class ImageMaskEditor {
			constructor() {
				this.canvas = document.getElementById('imageCanvas');
				this.ctx = this.canvas.getContext('2d');
				// 创建遮罩画布
				this.maskCanvas = document.createElement('canvas');
				this.maskCtx = this.maskCanvas.getContext('2d');
				this.isDrawing = false;
				this.isPanning = false;  // 是否正在平移
				this.lastTouchDistance = 0;  // 用于双指缩放
				this.scale = 1;
				this.offsetX = 0;
				this.offsetY = 0;
				this.lastX = 0;
				this.lastY = 0;
				this.brushSize = 10;
				this.originalImage = null;
				this.touchStartTime = 0;  // 用于区分点击和拖动
				this.imageMD5 = null;  // 存储原图的MD5值
				this.isMaskModified = false;  // 新增：标记遮罩是否被修改
				// 添加历史记录数组
				this.history = [];
				this.maxHistoryLength = 50; // 最大历史记录数
				// 新增：标记原图是否已上传
				this.isImageUploaded = false;

				// 创建Toast提示元素
				this.toast = document.createElement('div');
				this.toast.className = 'toast';
				document.body.appendChild(this.toast);

				this.setupEventListeners();
			}

			setupEventListeners() {
				// 文件输入处理
				document.getElementById('imageInput').addEventListener('change', (e) => this.loadImage(e));

				// 画笔大小控制
				document.getElementById('brushSizeInput').addEventListener('input', (e) => {
					this.brushSize = parseInt(e.target.value);
					document.getElementById('brushSize').textContent = this.brushSize;
					// 添加预览圆圈
					this.showBrushPreview(e);
				});

				// 添加鼠标移动时的画笔预览
				this.canvas.addEventListener('mousemove', (e) => {
					if (!this.isDrawing) {
						this.showBrushPreview(e);
					}
				});

				// 鼠标离开时清除预览
				this.canvas.addEventListener('mouseout', () => {
					this.redrawCanvas();
				});

				// 绘画事件
				this.canvas.addEventListener('pointerdown', (e) => this.startDrawing(e));
				this.canvas.addEventListener('pointermove', (e) => this.draw(e));
				this.canvas.addEventListener('pointerup', () => this.stopDrawing());
				this.canvas.addEventListener('pointerout', () => this.stopDrawing());

				// 缩放控制
				document.getElementById('zoomIn').addEventListener('click', () => this.zoom(1.2));
				document.getElementById('zoomOut').addEventListener('click', () => this.zoom(0.8));
				document.getElementById('resetZoom').addEventListener('click', () => this.resetZoom());

				// 方向控制
				document.getElementById('moveLeft').addEventListener('click', () => this.move('left'));
				document.getElementById('moveRight').addEventListener('click', () => this.move('right'));
				document.getElementById('moveUp').addEventListener('click', () => this.move('up'));
				document.getElementById('moveDown').addEventListener('click', () => this.move('down'));

				// 上传按钮事件 - 添加存在性检查
				const uploadImageLamaBtn = document.getElementById('uploadImageLamaBtn');
				if (uploadImageLamaBtn) {
					uploadImageLamaBtn.addEventListener('click', () => this.uploadLama());
				}

				// 添加撤销按钮事件
				document.getElementById('undoBtn').addEventListener('click', () => this.undo());

				// 添加清除按钮事件
				document.getElementById('clearBtn').addEventListener('click', () => this.clearMask());
			}

			// 计算文件的MD5值
			async calculateMD5(file) {
				return new Promise((resolve, reject) => {
					const reader = new FileReader();
					reader.onload = function (e) {
						const spark = new SparkMD5.ArrayBuffer();
						spark.append(e.target.result);
						resolve(spark.end());
					};
					reader.onerror = function (e) {
						reject('Error calculating MD5');
					};
					reader.readAsArrayBuffer(file);
				});
			}

			async loadImage(event) {
				const file = event.target.files[0];
				if (!file) return;

				try {
					// 计算并存储MD5值
					this.imageMD5 = await this.calculateMD5(file);
					// 重置遮罩修改状态
					this.isMaskModified = false;

					const reader = new FileReader();
					reader.onload = async (e) => {
						this.originalImage = new Image();
						this.originalImage.onload = async () => {
							// 添加图片尺寸限制逻辑
							let width = this.originalImage.width;
							let height = this.originalImage.height;

							// 检查是否需要缩放
							const MAX_SIZE = 1920;
							if (width > MAX_SIZE || height > MAX_SIZE) {
								if (width > height) {
									// 宽度为主要维度
									height = Math.round((height * MAX_SIZE) / width);
									width = MAX_SIZE;
								} else {
									// 高度为主要维度
									width = Math.round((width * MAX_SIZE) / height);
									height = MAX_SIZE;
								}

								// 创建临时画布进行缩放
								const tempCanvas = document.createElement('canvas');
								tempCanvas.width = width;
								tempCanvas.height = height;
								const tempCtx = tempCanvas.getContext('2d');

								// 使用高质量的图像缩放
								tempCtx.imageSmoothingEnabled = true;
								tempCtx.imageSmoothingQuality = 'high';
								tempCtx.drawImage(this.originalImage, 0, 0, width, height);

								// 创建新的Image对象存储缩放后的图片
								const scaledImage = new Image();
								scaledImage.src = tempCanvas.toDataURL('image/jpeg', 0.95);

								await new Promise(resolve => {
									scaledImage.onload = resolve;
								});

								this.originalImage = scaledImage;
							}

							// 设置画布尺寸为缩放后的尺寸
							this.canvas.width = width;
							this.canvas.height = height;
							// 设置遮罩画布尺寸
							this.maskCanvas.width = width;
							this.maskCanvas.height = height;

							// 尝试从服务器加载遮罩
							try {
								const maskResponse = await fetch(`image/${this.imageMD5}_mask.png`);
								if (maskResponse.ok) {
									// 如果遮罩存在，加载它
									const maskBlob = await maskResponse.blob();
									const maskUrl = URL.createObjectURL(maskBlob);
									const maskImage = new Image();
									maskImage.onload = () => {
										this.maskCtx.drawImage(maskImage, 0, 0, width, height);
										URL.revokeObjectURL(maskUrl);
										this.redrawCanvas();
									};
									maskImage.src = maskUrl;
								} else {
									// 如果遮罩不存在，创建新的黑色遮罩
									this.maskCtx.fillStyle = '#000';
									this.maskCtx.fillRect(0, 0, width, height);
								}
							} catch (error) {
								console.error('加载遮罩失败:', error);
								this.maskCtx.fillStyle = '#000';
								this.maskCtx.fillRect(0, 0, width, height);
							}

							// 计算适应屏幕的缩放比例
							const container = this.canvas.parentElement;
							const containerWidth = container.clientWidth;
							const containerHeight = container.clientHeight;
							const scaleX = (containerWidth - 40) / width;
							const scaleY = (containerHeight - 40) / height;
							this.scale = Math.min(scaleX, scaleY, 1);

							// 计算居中位置, 修改此处
							this.offsetX = (containerWidth - width * this.scale) / 2;
							this.offsetY = 0; // 将 offsetY 设置为 0

							this.redrawCanvas();

							// 如果图片被缩放了，显示提示信息
							if (this.originalImage.width !== this.canvas.width || this.originalImage.height !== this.canvas.height) {
								this.showToast(`图片已自动缩放至 ${width}x${height}`);
							}
							// 重置图片上传状态
							this.isImageUploaded = false;
						};
						this.originalImage.src = e.target.result;
					};
					reader.readAsDataURL(file);
				} catch (error) {
					this.showToast('加载图片出错: ' + error.message);
				}
			}

			redrawCanvas() {
				this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

				// 保存当前状态
				this.ctx.save();

				// 应用缩放和平移
				this.ctx.translate(this.offsetX, this.offsetY);
				this.ctx.scale(this.scale, this.scale);

				// 绘制原始图片
				if (this.originalImage) {
					this.ctx.drawImage(this.originalImage, 0, 0);
					// 叠加遮罩
					this.ctx.globalAlpha = 0.5;
					this.ctx.drawImage(this.maskCanvas, 0, 0);
				}

				// 恢复状态
				this.ctx.restore();
			}

			startDrawing(e) {
				this.isDrawing = true;
				const pos = this.getMousePos(e);
				this.lastX = pos.x;
				this.lastY = pos.y;
				// 开始绘制前保存状态
				this.saveToHistory();
				// 立即绘制一个点
				this.drawPoint(pos.x, pos.y);
			}

			draw(e) {
				if (!this.isDrawing) return;

				const pos = this.getMousePos(e);
				this.drawPoint(pos.x, pos.y);

				// 连接上一个点和当前点，使线条更流畅
				this.maskCtx.beginPath();
				this.maskCtx.strokeStyle = '#fff';
				this.maskCtx.lineWidth = (this.brushSize * 2) / this.scale;
				this.maskCtx.lineCap = 'round';
				this.maskCtx.moveTo(this.lastX, this.lastY);
				this.maskCtx.lineTo(pos.x, pos.y);
				this.maskCtx.stroke();

				this.lastX = pos.x;
				this.lastY = pos.y;
				this.redrawCanvas();
			}

			drawPoint(x, y) {
				// 在遮罩画布上绘制白色圆点
				this.maskCtx.fillStyle = '#fff';
				this.maskCtx.beginPath();
				this.maskCtx.arc(x, y, this.brushSize / this.scale, 0, Math.PI * 2);
				this.maskCtx.fill();
				this.redrawCanvas();
			}

			stopDrawing() {
				this.isDrawing = false;
			}

			getMousePos(e) {
				const rect = this.canvas.getBoundingClientRect();
				return {
					x: (e.clientX - rect.left - this.offsetX) / this.scale,
					y: (e.clientY - rect.top - this.offsetY) / this.scale
				};
			}

			zoom(factor) {
				const oldScale = this.scale;
				this.scale *= factor;
				this.scale = Math.min(Math.max(0.1, this.scale), 10);

				// 调整偏移以保持鼠标位置不变
				const canvasCenterX = this.canvas.width / 2;
				const canvasCenterY = this.canvas.height / 2;

				this.offsetX -= (canvasCenterX * (this.scale - oldScale));
				this.offsetY -= (canvasCenterY * (this.scale - oldScale));

				this.redrawCanvas();
			}

			resetZoom() {
				this.scale = 1;
				this.offsetX = 0;
				this.offsetY = 0;
				this.redrawCanvas();
			}

			async saveMask() {
				if (!this.imageMD5) {
					this.showToast('请先选择图片');
					return;
				}

				// 下载遮罩文件
				const link = document.createElement('a');
				link.download = `${this.imageMD5}_mask.png`;
				link.href = this.maskCanvas.toDataURL('image/png', 1.0);
				link.click();
			}

			// 显示Toast提示
			showToast(message, duration = 5000) {
				this.toast.textContent = message;
				this.toast.style.display = 'block';

				// 3秒后自动隐藏
				// 清除之前的定时器
				if (this.toastTimeout) {
					clearTimeout(this.toastTimeout);
				}

				this.toastTimeout = setTimeout(() => {
					this.toast.style.display = 'none';
					this.toastTimeout = null; // 清除引用
				}, duration);
			}

			// 修改uploadImage方法
			async uploadImage() {
				if (!this.originalImage) {
					this.showToast('请先选择一张图片');
					return;
				}
				this.isImageUploaded = false; // 标记图片已上传
				this.showToast('开始原图图片上传 ... ');
				// 将原始图片转换为 Blob
				const response = await fetch(this.originalImage.src);
				const blob = await response.blob();

				const formData = new FormData();
				formData.append('file', blob, 'image.png');
				formData.append('md5', this.imageMD5);  // 添加MD5值

				try {
					const response = await fetch('/upload', {
						method: 'POST',
						body: formData
					});
					const result = await response.json();
					if (result.status === 'success') {
						this.showToast('原图上传成功');
						this.isImageUploaded = true; // 标记图片已上传
					} else {
						this.showToast('原图上传失败: ' + result.message);
					}
				} catch (error) {
					this.showToast('原图上传出错: ' + error.message);
				}
			}

			// 修改uploadMask方法
			async uploadMask() {
				if (!this.maskCanvas || !this.imageMD5) {
					this.showToast('请先选择图片并创建遮罩');
					return;
				}

				// 返回一个新的Promise
				return new Promise((resolve, reject) => {
					this.maskCanvas.toBlob(async (blob) => {
						const formData = new FormData();
						formData.append('file', blob, 'mask.png');
						formData.append('md5', this.imageMD5);

						this.showToast('开始遮罩图片上传 ... ');

						try {
							const response = await fetch('/upload', {
								method: 'POST',
								body: formData
							});
							const result = await response.json();
							if (result.status === 'success') {
								this.showToast('遮罩图片上传成功');
								this.isMaskModified = false;
								resolve(result); // 成功时resolve
							} else {
								this.showToast('遮罩图片上传失败: ' + result.message);
								reject(new Error(result.message)); // 失败时reject
							}
						} catch (error) {
							this.showToast('遮罩图片上传出错: ' + error.message);
							reject(error); // 出错时reject
						}
					}, 'image/png');
				});
			}

			// 修改 uploadLama 方法
			async uploadLama() {
				if (!this.maskCanvas || !this.imageMD5) {
					this.showToast('请先选择图片并创建遮罩');
					return;
				}

				// 如果原始图片未上传，则先上传
				if (!this.isImageUploaded) {
                    this.showToast('原图还未上传，正在上传...');
					await this.uploadImage();
				}

				// 如果遮罩被修改，先上传遮罩
				if (this.isMaskModified) {
					this.showToast('遮罩已修改，正在上传...');
					await this.uploadMask();
				}

				this.showToast('开始Lama图像修复...',120000);
				try {
					const response = await fetch('/lama', {
						method: 'POST',
						headers: {
							'Content-Type': 'application/json'
						},
						body: JSON.stringify({
							md5: this.imageMD5
						})
					});

					const result = await response.json();

					if (result.status === 'success') {
                        this.showToast('OK: ' + result.message);
					    await refreshTaskList(); // 修改为 await 调用
					} else {
						this.showToast('修复失败: ' + result.message);
					}
				} catch (error) {
					this.showToast('修复出错: ' + error.message);
				}
			}
			move(direction) {
				if (!this.originalImage) return;

				const moveDistance = {
					left: -this.canvas.width * 0.01,
					right: this.canvas.width * 0.01,
					up: -this.canvas.height * 0.01,
					down: this.canvas.height * 0.01
				};

				const distance = moveDistance[direction];
				if (direction === 'left' || direction === 'right') {
					this.offsetX += distance;
				} else {
					this.offsetY += distance;
				}

				this.redrawCanvas();
			}

			showBrushPreview(e) {
				const pos = this.getMousePos(e);
				this.redrawCanvas();

				// 在当前鼠标位置绘制预览圆圈
				this.ctx.save();
				this.ctx.translate(this.offsetX, this.offsetY);
				this.ctx.scale(this.scale, this.scale);

				this.ctx.beginPath();
				this.ctx.arc(pos.x, pos.y, this.brushSize / this.scale, 0, Math.PI * 2);
				this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
				this.ctx.lineWidth = 1 / this.scale;
				this.ctx.stroke();

				this.ctx.restore();
			}

			// 保存当前状态到历史记录
			saveToHistory() {
				const imageData = this.maskCtx.getImageData(0, 0, this.maskCanvas.width, this.maskCanvas.height);
				this.history.push(imageData);
				if (this.history.length > this.maxHistoryLength) {
					this.history.shift(); // 移除最老的记录
				}
				// 标记遮罩已被修改
				this.isMaskModified = true;
			}

			// 撤销功能
			undo() {
				if (this.history.length > 0) {
					const lastState = this.history.pop();
					this.maskCtx.putImageData(lastState, 0, 0);
					this.redrawCanvas();
					// 标记遮罩已被修改
					this.isMaskModified = true;
				}
			}

			// 清除遮罩功能
			clearMask() {
				if (!this.originalImage) {
					alert('请先选择图片');
					return;
				}

				// 保存当前状态到历史记录
				this.saveToHistory();

				// 清除遮罩为黑色
				this.maskCtx.fillStyle = '#000';
				this.maskCtx.fillRect(0, 0, this.maskCanvas.width, this.maskCanvas.height);
				this.redrawCanvas();
			}
		}

		// 添加全局变量
		let currentPage = 1;
		let totalPages = 1;

		// 修改getTaskStatus函数
		async function getTaskStatus(page = 1) {
			try {
				const response = await fetch(`/tasks?page=${page}`);
				if (!response.ok) {
					throw new Error(`HTTP error! status: ${response.status}`);
				}
				return await response.json();
			} catch (error) {
				console.error('获取任务状态失败:', error);
				throw error;
			}
		}

		// 修改updateTaskList方法
		function updateTaskList(data) {
			const taskList = document.getElementById('taskList');
			const taskCount = document.getElementById('taskCount');
			const tasks = data.tasks;
			
			// 更新任务数量
			const pendingTasks = Object.values(tasks).filter(t => t.status === 'pending').length;
			const processingTasks = Object.values(tasks).filter(t => t.status === 'processing').length;
			taskCount.textContent = `共${data.total}个任务 (${pendingTasks}待处理/${processingTasks}处理中)`;
			
			// 生成任务列表HTML
			const taskItems = Object.entries(tasks).map(([md5, task]) => {
				const statusText = {
					'pending': '等待处理',
					'processing': '处理中',
					'completed': '已完成',
					'error': '失败'
				}[task.status];
				
				const resultImage = task.status === 'completed' ? 
					`<img src="/image/${md5}_lama_thumb.jpg?t=${Date.now()}" class="task-result" onclick="window.open('/image/${md5}_lama.jpg?t=${Date.now()}')">` : '';
				
				const timeStr = new Date(task.create_time * 1000).toLocaleString();
				
				return `
					<div class="task-item">
						<div class="task-info">
							<div class="task-header">
								<span class="task-status ${task.status}">${statusText}</span>
								<span class="task-time">${timeStr}</span>
							</div>
						</div>
						${resultImage}
					</div>
				`;
			}).join('');
			
			taskList.innerHTML = taskItems || '<div class="no-tasks">暂无任务</div>';
			
			// 更新分页
			updatePagination(data);
		}
		
		// 添加分页更新函数
		function updatePagination(data) {
			const pagination = document.getElementById('taskPagination');
			currentPage = data.page;
			totalPages = data.total_pages;
			
			let html = '';
			
			// 上一页按钮
			html += `<button class="page-btn" ${currentPage === 1 ? 'disabled' : ''} onclick="changePage(${currentPage - 1})">上一页</button>`;
			
			// 页码按钮
			for (let i = 1; i <= totalPages; i++) {
				if (i === 1 || i === totalPages || (i >= currentPage - 2 && i <= currentPage + 2)) {
					html += `<button class="page-btn ${i === currentPage ? 'active' : ''}" onclick="changePage(${i})">${i}</button>`;
				} else if (i === currentPage - 3 || i === currentPage + 3) {
					html += `<span class="page-info">...</span>`;
				}
			}
			
			// 下一页按钮
			html += `<button class="page-btn" ${currentPage === totalPages ? 'disabled' : ''} onclick="changePage(${currentPage + 1})">下一页</button>`;
			
			// 显示总数
			html += `<span class="page-info">第${currentPage}/${totalPages}页</span>`;
			
			pagination.innerHTML = html;
		}
		
		// 添加页码切换函数
		async function changePage(page) {
			if (page < 1 || page > totalPages) return;
			
			try {
				const data = await getTaskStatus(page);
				updateTaskList(data);
			} catch (error) {
				console.error('切换页面失败:', error);
				showToast('切换页面失败: ' + error.message);
			}
		}
        async function refreshTaskList() {
            const refreshBtn = document.getElementById('refreshTasksBtn');
            refreshBtn.classList.add('spinning');
            refreshBtn.disabled = true;

            try {
                const data = await getTaskStatus(currentPage);
                updateTaskList(data);
            } catch (error) {
                console.error('刷新任务列表失败:', error);
                showToast('刷新任务列表失败: ' + error.message);
            } finally {
                setTimeout(() => {
                    refreshBtn.classList.remove('spinning');
                    refreshBtn.disabled = false;
                }, 500);
            }
        }
		// 修改刷新按钮事件处理
		document.getElementById('refreshTasksBtn').addEventListener('click', () => {
			refreshTaskList();
		});

		// 页面加载时获取一次任务列表
		getTaskStatus(currentPage).then(updateTaskList).catch(error => {
			console.error('初始化任务列表失败:', error);
			showToast('获取任务列表失败: ' + error.message);
		});

		// 初始化ImageMaskEditor
		window.addEventListener('load', () => {
			window.editor = new ImageMaskEditor();
		});

		// 添加任务面板折叠/展开功能
		document.addEventListener('DOMContentLoaded', function() {
			const taskPanel = document.getElementById('taskPanel');
			const taskHeader = document.getElementById('taskHeader');
			
			// 从localStorage获取面板状态
			const isPanelCollapsed = localStorage.getItem('taskPanelCollapsed') === 'true';
			if (isPanelCollapsed) {
				taskPanel.classList.add('collapsed');
			}
			
			// 添加点击事件处理
			taskHeader.addEventListener('click', function(e) {
				// 如果点击的是刷新按钮,不处理折叠
				if (e.target.closest('#refreshTasksBtn')) {
					return;
				}
				
				taskPanel.classList.toggle('collapsed');
				// 保存状态到localStorage
				localStorage.setItem('taskPanelCollapsed', taskPanel.classList.contains('collapsed'));
			});
		});
	</script>
</body>

</html>
<!-- 功能描述(不得删除此段，每次更新后，请更新以下功能描述)：
1. 图片选择和显示：
	- 支持选择本地图片文件
	- 首次加载自动缩放以显示完整图片
	- 自动居中显示
	- 保持原始图片比例

2. 涂抹功能：
	- 可调节画笔大小（1-500像素）
	- 支持鼠标和触摸屏操作
	- 涂抹区域显示为半透明效果
	- 支持撤销操作（最多50步）
	- 支持一键清除遮罩

3. 缩放和平移控制：
	- 支持放大/缩小查看
	- 可重置回原始大小
	- 缩放范围：0.1x - 10x
	- 支持画布拖动平移
	- 支持触摸手势操作
	- 支持方向键精确移动（每次移动1%）

4. 遮罩导出：
	- 导出为PNG格式
	- 涂抹区域为白色
	- 未涂抹区域为黑色
	- 保持原图尺寸
	- 纯黑白两色，无透明度

5. 移动端支持：
	- 响应式界面设计
	- 触摸屏绘制支持
	- 自适应屏幕大小
	- 手势操作支持：
		* 短按拖动：涂抹
		* 长按拖动：移动画布
		* 双指缩放：调整画布大小

使用说明：
1. 点击选择图片上传，图片会自动缩放显示
2. 使用滑块调节画笔大小
3. 在图片上按住鼠标或触摸拖动进行涂抹
4. 使用缩放按钮或手势调整视图
5. 使用方向按钮精确移动画布位置
6. 长按拖动可自由移动画布
7. 点击"撤销"可以回退上一步操作
8. 点击"清除"可以清除所有遮罩
9. 点击"保存遮罩"导出黑白遮罩图片

-->